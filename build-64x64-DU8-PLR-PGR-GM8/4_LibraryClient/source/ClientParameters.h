/*******************************************************************************
* Copyright (C) 2016-2019 Advanced Micro Devices, Inc. All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell cop-
* ies of the Software, and to permit persons to whom the Software is furnished
* to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IM-
* PLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNE-
* CTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*******************************************************************************/

/**************************************************
* This file was generated by Tensile:             *
* https://github.com/ROCmSoftwarePlatform/Tensile *
**************************************************/


#include "Solutions.h"
#include "Tensile.h"
typedef enum {
    enum_float,
    enum_double,
    enum_TensileComplexFloat,
    enum_TensileComplexDouble
#ifdef Tensile_ENABLE_HALF
    ,enum_TensileHalf
#endif
    ,enum_TensileInt8x4
    ,enum_TensileInt32
    ,enum_tensile_bfloat16
} DataTypeEnum;

// Debug Params
const unsigned printTensorA=0;
const unsigned printTensorB=0;
const unsigned printTensorC=0;
const unsigned printTensorD=0;
const bool printWinnersOnly=false;

const char indexChars[19] = "IJKLMNOPQRSTUVWXYZ";
unsigned int functionIdx;
unsigned int dataTypeIdx;
unsigned int problemTypeIdx;

const unsigned int numFunctions = 1;
/* data types */
const unsigned int numDataTypes = 1;
const DataTypeEnum dataTypeEnums[numDataTypes] = { enum_float };
const unsigned int bytesPerElement[numDataTypes] = { 4 };
const unsigned int numFlopsPerMac[numDataTypes] = { 2 };
#define Tensile_DATA_TYPE_FLOAT
/* problem types */
const unsigned int numProblemTypes = 1;
const unsigned int numIndicesC[numProblemTypes] = { 3 };
const unsigned int numIndicesA[numProblemTypes] = { 3 };
const unsigned int maxNumIndicesA = 3;
const unsigned int numIndicesB[numProblemTypes] = { 3 };
const unsigned int maxNumIndicesB = 3;
const unsigned int indexAssignmentsA[numProblemTypes][maxNumIndicesA] = {
  { 0, 3, 2 }
};
const unsigned int indexAssignmentsB[numProblemTypes][maxNumIndicesB] = {
  { 3, 1, 2 }
};
const unsigned int numIndicesLD = 4;
const unsigned int indexAssignmentsLD[numIndicesLD] = { 4, 5, 6, 7};
bool useBeta[numProblemTypes] = { true };
const bool complexConjugateA[numProblemTypes] = { false };
const bool complexConjugateB[numProblemTypes] = { false };

// dataTypeIdxSerial, problemTypeIdxForDataType, problemTypeIdxSerial, functionIdxSerial, functionIdxForDataType, functionIdxForProblemType
const unsigned int functionInfo[numFunctions][6] = {
  { 0, 0, 0, 0, 0, 0 } };
const unsigned int maxNumIndices = 4;
const unsigned int totalIndices[numProblemTypes] = { 4 };
unsigned int userSizes[maxNumIndices];
unsigned int minStrides[4] = {0, 0, 0, 0};
size_t maxSizeD;
size_t maxSizeC;
size_t maxSizeA;
size_t maxSizeB;

/* current problem size */

const char *functionNames[numFunctions] = {
    "tensile_Cijk_Ailk_Bljk_SB"
 };
/* runtime structures */
TensileStatus status;
hipStream_t stream;

void *deviceD;
void *deviceC;
void *deviceA;
void *deviceB;

/* benchmarking parameters */
size_t validationStride;
static bool useHighPrecisionAccumulate = false;

/* generated call to reference */
template<typename DataType, typename DestDataType, typename ComputeDataType>
TensileStatus generatedCallToReferenceCPU(
    const unsigned int *sizes,
    const unsigned int *minStrides,
    DestDataType *referenceD,
    DestDataType *referenceC,
    DataType *initialA,
    DataType *initialB,
    const unsigned int lda,
    const unsigned int ldb,
    const unsigned int ldc,
    const unsigned int ldd,
    const unsigned int stride_a,
    const unsigned int stride_b,
    const unsigned int stride_c,
    const unsigned int stride_d,
    ComputeDataType alpha,
    ComputeDataType beta,
    bool useHighPrecisionAccumulate) {
  return tensileReferenceCPU(
      referenceD,
      referenceC,
      initialA,
      initialB,
      lda,
      ldb,
      ldc,
      ldd,
      stride_a,
      stride_b,
      stride_c,
      stride_d,
      alpha,
      beta,
      totalIndices[problemTypeIdx],
      sizes,
      minStrides,
      numIndicesC[problemTypeIdx],
      numIndicesA[problemTypeIdx],
      numIndicesB[problemTypeIdx],
      indexAssignmentsA[problemTypeIdx],
      indexAssignmentsB[problemTypeIdx],
      complexConjugateA[problemTypeIdx],
      complexConjugateB[problemTypeIdx],
      validationStride,
      useHighPrecisionAccumulate);
};

/* generated call to function */
template<typename DataType, typename DestDataType, typename ComputeDataType>
TensileStatus generatedCallTo_tensile(
    unsigned int *sizes,
    unsigned int *minStrides,
    ComputeDataType alpha,
    ComputeDataType beta,
    unsigned int lda,
    unsigned int ldb,
    unsigned int ldc,
    unsigned int ldd,
    unsigned int strideA,
    unsigned int strideB,
    unsigned int strideC,
    unsigned int strideD,
    unsigned int numEvents = 0,
    hipEvent_t *startEvent = NULL,
    hipEvent_t *stopEvent = NULL );

template<>
inline TensileStatus generatedCallTo_tensile<float, float, float>(
    unsigned int *sizes,
    unsigned int *minStrides,
    float alpha,
    float beta,
    unsigned int lda,
    unsigned int ldb,
    unsigned int ldc,
    unsigned int ldd,
    unsigned int strideA,
    unsigned int strideB,
    unsigned int strideC,
    unsigned int strideD,
    unsigned int numEvents, 
    hipEvent_t *startEvent,
    hipEvent_t *stopEvent ) {

    unsigned int functionIdxForDataType = functionInfo[functionIdx][4];
    unsigned int strideD0I = 1;
    unsigned int strideD1J = 1*sizes[0];
    unsigned int strideD2K = 1*sizes[0]*sizes[1];
    if (strideD != std::numeric_limits<unsigned int>::max())  strideD2K = strideD;
    unsigned int strideC0I = 1;
    unsigned int strideC1J = 1*sizes[0];
    unsigned int strideC2K = 1*sizes[0]*sizes[1];
    if (strideC != std::numeric_limits<unsigned int>::max())  strideC2K = strideC;
    unsigned int strideA0I = 1;
    unsigned int strideA1L = 1*sizes[0];
    unsigned int strideA2K = 1*sizes[0]*sizes[3];
    if (strideA != std::numeric_limits<unsigned int>::max())  strideA2K = strideA;
    unsigned int strideB0L = 1;
    unsigned int strideB1J = 1*sizes[3];
    unsigned int strideB2K = 1*sizes[3]*sizes[1];
    if (strideB != std::numeric_limits<unsigned int>::max())  strideB2K = strideB;
    unsigned int sizeI = sizes[0];
    unsigned int sizeJ = sizes[1];
    unsigned int sizeK = sizes[2];
    unsigned int sizeL = sizes[3];
    // call solution function
    return tensile_Cijk_Ailk_Bljk_SB(
        static_cast<float *>(deviceD),
        static_cast<float *>(deviceC),
        static_cast<float *>(deviceA),
        static_cast<float *>(deviceB),
        alpha,
        beta,
        strideD1J,
        strideD2K,
        strideC1J,
        strideC2K,
        strideA1L,
        strideA2K,
        strideB1J,
        strideB2K,
        sizeI,
        sizeJ,
        sizeK,
        sizeL
, stream, numEvents, startEvent, stopEvent);
};
/* generated call to function */
template<typename DataType, typename DestDataType, typename ComputeDataType>
const char * generatedCallTo_tensileGetSolutionName(
    unsigned int *sizes,
    unsigned int *minStrides,
    ComputeDataType alpha,
    ComputeDataType beta,
    unsigned int lda,
    unsigned int ldb,
    unsigned int ldc,
    unsigned int ldd,
    unsigned int strideA,
    unsigned int strideB,
    unsigned int strideC,
    unsigned int strideD,
    unsigned int numEvents = 0,
    hipEvent_t *startEvent = NULL,
    hipEvent_t *stopEvent = NULL );

template<>
inline const char * generatedCallTo_tensileGetSolutionName<float, float, float>(
    unsigned int *sizes,
    unsigned int *minStrides,
    float alpha,
    float beta,
    unsigned int lda,
    unsigned int ldb,
    unsigned int ldc,
    unsigned int ldd,
    unsigned int strideA,
    unsigned int strideB,
    unsigned int strideC,
    unsigned int strideD,
    unsigned int numEvents, 
    hipEvent_t *startEvent,
    hipEvent_t *stopEvent ) {

    unsigned int functionIdxForDataType = functionInfo[functionIdx][4];
    unsigned int strideD0I = 1;
    unsigned int strideD1J = 1*sizes[0];
    unsigned int strideD2K = 1*sizes[0]*sizes[1];
    if (strideD != std::numeric_limits<unsigned int>::max())  strideD2K = strideD;
    unsigned int strideC0I = 1;
    unsigned int strideC1J = 1*sizes[0];
    unsigned int strideC2K = 1*sizes[0]*sizes[1];
    if (strideC != std::numeric_limits<unsigned int>::max())  strideC2K = strideC;
    unsigned int strideA0I = 1;
    unsigned int strideA1L = 1*sizes[0];
    unsigned int strideA2K = 1*sizes[0]*sizes[3];
    if (strideA != std::numeric_limits<unsigned int>::max())  strideA2K = strideA;
    unsigned int strideB0L = 1;
    unsigned int strideB1J = 1*sizes[3];
    unsigned int strideB2K = 1*sizes[3]*sizes[1];
    if (strideB != std::numeric_limits<unsigned int>::max())  strideB2K = strideB;
    unsigned int sizeI = sizes[0];
    unsigned int sizeJ = sizes[1];
    unsigned int sizeK = sizes[2];
    unsigned int sizeL = sizes[3];
    // call solution function
    return tensileGetSolutionName_Cijk_Ailk_Bljk_SB(
        strideD1J,
        strideD2K,
        strideC1J,
        strideC2K,
        strideA1L,
        strideA2K,
        strideB1J,
        strideB2K,
        sizeI,
        sizeJ,
        sizeK,
        sizeL
);
};
